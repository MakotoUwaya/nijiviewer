/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;
// biome-ignore lint/suspicious/noExplicitAny: <explanation>
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
    ? OneOf<[XOR<A, B>, ...Rest]>
    : never;

export interface paths {
  "/live": {
    /**
     * Query Live and Upcoming Videos
     * @description This is somewhat similar to calling `/videos`.
     *
     * However, this endpoint imposes these default values on the query parameters: You can choose to override them by providing your own values.
     *
     *     status: [STATUSES.LIVE, STATUSES.UPCOMING].join(','),
     *     type: 'stream',
     *     sort: 'available_at',
     *     order: 'asc',
     *     max_upcoming_hours: 48,
     *     limit: 9999,
     *     include: live_info + query's include
     */
    get: {
      parameters: {
        query?: {
          channel_id?: components["parameters"]["videoChannelId"];
          status?: components["parameters"]["videoStatus"];
          lang?: components["parameters"]["videoLang"];
          type?: components["parameters"]["videoType"];
          topic?: components["parameters"]["videoTopicId"];
          include?: components["parameters"]["videoInclude"];
          org?: components["parameters"]["org"];
          mentioned_channel_id?: components["parameters"]["videoMentionedChannelId"];
          sort?: components["parameters"]["videoSort"];
          order?: components["parameters"]["order"];
          limit?: components["parameters"]["limit"];
          offset?: components["parameters"]["offset"];
          paginated?: components["parameters"]["paginated"];
          max_upcoming_hours?: components["parameters"]["videoMaxUpcomingHours"];
          id?: components["parameters"]["videoIdentifier"];
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": OneOf<
              [
                components["schemas"]["Video"][],
                {
                  total?: number;
                  items?: components["schemas"]["Video"][];
                },
              ]
            >;
          };
        };
      };
    };
  };
  "/videos": {
    /**
     * Query Videos
     * @description Pretty much everything you need. This is the most 'vanilla' variant with almost no preset values, and `/channels/{channelId}/{type}` and `/live` endpoints both use the same query structure but provision default values differently for some of the query params.
     *
     * Not as powerful at searching arbitrary text as the Search API (currently not documented/available).
     */
    get: {
      parameters: {
        query?: {
          channel_id?: components["parameters"]["videoChannelId"];
          status?: components["parameters"]["videoStatus"];
          lang?: components["parameters"]["videoLang"];
          type?: components["parameters"]["videoType"];
          topic?: components["parameters"]["videoTopicId"];
          include?: components["parameters"]["videoInclude"];
          org?: components["parameters"]["org"];
          mentioned_channel_id?: components["parameters"]["videoMentionedChannelId"];
          sort?: components["parameters"]["videoSort"];
          order?: components["parameters"]["order"];
          limit?: components["parameters"]["limit"];
          offset?: components["parameters"]["offset"];
          paginated?: components["parameters"]["paginated"];
          max_upcoming_hours?: components["parameters"]["videoMaxUpcomingHours"];
          id?: components["parameters"]["videoIdentifier"];
          /** @description ISO8601 Date String for minimum `available_at`. (`available_at` is the most accurate timestamp of when a video has gone live or became viewable - it is the first non null value of the `start_actual`, `start_scheduled` or `published_at` fields) */
          from?: string;
          /** @description ISO8601 Date String for maximum `available_at` */
          to?: string;
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": components["schemas"]["VideoFull"];
          };
        };
      };
    };
  };
  "/channels/{channelId}": {
    /** Get Channel Information */
    get: operations["get-v2-channels-channelId"];
    parameters: {
      path: {
        channelId: components["parameters"]["channelId"];
      };
    };
  };
  "/channels/{channelId}/{type}": {
    /**
     * Query Videos Related to Channel
     * @description A simplified endpoint for access channel specific data. If you want more customization, the same result can be obtained by calling the `/videos` endpoint.
     */
    get: operations["get-v2-channels-channelId-clips"];
    parameters: {
      path: {
        channelId: components["parameters"]["channelId"];
        /** @description The type of video resource to fetch. Clips finds clip videos of a `vtuber` channel, Video finds the `channelId` channel's uploads, and collabs finds videos uploaded by other channels that mention this `channelId` */
        type: "clips" | "videos" | "collabs";
      };
    };
  };
  "/users/live": {
    /**
     * Quickly Access Live / Upcoming for a set of Channels
     * @description This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.
     *
     * We recommends using this if you have a fixed set of channel IDs to look up status for.
     */
    get: operations["get-cached-live"];
  };
  "/videos/{videoId}": {
    /**
     * Get a single Video's metadata
     * @description Retrieves a video object.
     *
     * Also retrieves Comments if query parameter `c` is set.
     *
     * Also retrieves Recommendations if query parameter `lang` is set
     */
    get: operations["get-videos-videoId"];
    parameters: {
      path: {
        videoId: components["parameters"]["videoId"];
      };
    };
  };
  "/channels": {
    /** List Channels */
    get: operations["get-channels"];
  };
  "/search/videoSearch": {
    /**
     * @description A flexible endpoint for retrieving videos that satisfy multiple conditions, where the "any" statement means an OR condition and "all" means an AND condition.
     *
     * Searching for topics and clips is not supported, because clips do not contain topic_ids
     */
    post: operations["post-search-videoSearch"];
  };
  "/search/commentSearch": {
    /** @description A flexible endpoint to search for comments on videos that satisfy multiple conditions, where "any" means OR conditions and "all" means AND conditions. */
    post: operations["post-search-commentSearch"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Comment: {
      comment_key?: string;
      video_id?: string;
      message?: string;
    };
    Channel: {
      id?: string;
      name?: string;
      english_name?: string | null;
      /** @enum {string} */
      type?: "vtuber" | "subber";
      org?: string | null;
      suborg?: string | null;
      photo?: string | null;
      banner?: string | null;
      twitter?: string | null;
      video_count?: string | null;
      subscriber_count?: string | null;
      view_count?: string | null;
      clip_count?: string | null;
      lang?: string | null;
      /** Format: date-time */
      published_at?: string;
      inactive?: boolean;
      description?: string;
    };
    ChannelWithGroup: {
      id?: string;
      name?: string;
      english_name?: string | null;
      /** @enum {string} */
      type?: "vtuber" | "subber";
      org?: string | null;
      group?: string | null;
      photo?: string | null;
      banner?: string | null;
      twitter?: string | null;
      video_count?: string | null;
      subscriber_count?: string | null;
      view_count?: string | null;
      clip_count?: string | null;
      lang?: string | null;
      /** Format: date-time */
      published_at?: string;
      inactive?: boolean;
      description?: string;
    };
    Video: {
      id?: string;
      title?: string;
      /** @enum {string} */
      type?: "stream" | "clip";
      /**
       * @description corresponds to a Topic ID, Videos of type `clip` cannot not have topic. Streams may or may not have topic.
       * @example minecraft
       */
      topic_id?: string | null;
      /** Format: date-time */
      published_at?: string | null;
      /**
       * Format: date-time
       * @description Takes on the first non-null value of end_actual, start_actual, start_scheduled, or published_at
       */
      available_at?: string;
      /** @description Duration of the video in seconds */
      duration?: number;
      /** @enum {string} */
      status?: "new" | "upcoming" | "live" | "past" | "missing";
      /**
       * Format: date-time
       * @description Included when includes contains 'live_info'
       */
      start_scheduled?: string | null;
      /**
       * Format: date-time
       * @description Included when includes contains 'live_info'
       */
      start_actual?: string | null;
      /**
       * Format: date-time
       * @description Included when includes contains 'live_info'
       */
      end_actual?: string | null;
      /** @description Included when includes contains 'live_info' */
      live_viewers?: number | null;
      /** @description Included when includes contains 'description' */
      description?: string;
      /** @description Number of tagged songs for this video */
      songcount?: number;
      channel_id?: string;
    };
    ChannelMin: {
      id?: string;
      name?: string;
      english_name?: string | null;
      /** @enum {string} */
      type?: "vtuber" | "subber";
      photo?: string;
    };
    VideoWithChannel: components["schemas"]["Video"] & {
      channel?: components["schemas"]["ChannelMin"];
    };
    /** VideoFull */
    VideoFull: components["schemas"]["Video"] & {
      /** @description Included when 'includes' contains 'clips' */
      clips?: components["schemas"]["VideoWithChannel"][] | null;
      /** @description Included when 'includes' contains 'sources' */
      sources?: components["schemas"]["VideoWithChannel"][] | null;
      /** @description Included when 'includes' contains 'refers' */
      refers?: components["schemas"]["VideoWithChannel"][] | null;
      /** @description Included when 'includes' contains 'simulcasts' */
      simulcasts?: components["schemas"]["VideoWithChannel"][] | null;
      /** @description VTubers mentioned by this video, Included when 'includes' contains 'mentions' */
      mentions?:
        | (components["schemas"]["ChannelMin"] & {
            /** @description Org of the Mentioned Channel */
            org?: string | null;
          })[]
        | null;
      /** @description Number of songs */
      songs?: number | null;
    };
  };
  responses: never;
  parameters: {
    /** @description Filter by type of video */
    videoType?: "stream" | "clip";
    /** @description A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter */
    videoLang?: string;
    /** @description Filter by video uploader channel id */
    videoChannelId?: string;
    /** @description Filter by video topic id */
    videoTopicId?: string;
    /** @description Sort by any returned video field */
    videoSort?: string;
    /** @description Order by ascending or descending */
    order?: "asc" | "desc";
    /** @description Comma separated string of extra info for video. Should be a string instead of an array. */
    videoInclude?: (
      | "clips"
      | "refers"
      | "sources"
      | "simulcasts"
      | "mentions"
      | "description"
      | "live_info"
      | "channel_stats"
      | "songs"
    )[];
    /** @description Results limit */
    limit?: number;
    /** @description Offset results */
    offset?: number;
    /** @description Filter by video status */
    videoStatus?: "new" | "upcoming" | "live" | "past" | "missing";
    /** @description Filter by mentioned channel id, excludes itself. Generally used to find collabs/clips that include the requested channel */
    videoMentionedChannelId?: string;
    /** @description Filter by clips that feature the org's talent or videos posted by the org's talent */
    org?: string;
    /** @description If paginated is set to any non-empty value, return an object with total, otherwise returns an array. */
    paginated?: string;
    /** @description ID of the Youtube Channel that is being queried */
    channelId: string;
    /** @description ID of a Youtube Video */
    videoId: string;
    /** @description Number of maximum hours upcoming to get upcoming videos by (for rejecting waiting rooms that are two years out) */
    videoMaxUpcomingHours?: number;
    /** @description A single Youtube Video ID. If Specified, only this video can be returned (may be filtered out by other conditions though) */
    videoIdentifier?: string;
    /** @description Type of Channel, whether it's a vtuber or a subber. Leave unset to query all. */
    channelType?: "subber" | "vtuber";
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /** Get Channel Information */
  "get-v2-channels-channelId": {
    parameters: {
      path: {
        channelId: components["parameters"]["channelId"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["Channel"];
        };
      };
    };
  };
  /**
   * Query Videos Related to Channel
   * @description A simplified endpoint for access channel specific data. If you want more customization, the same result can be obtained by calling the `/videos` endpoint.
   */
  "get-v2-channels-channelId-clips": {
    parameters: {
      query?: {
        lang?: components["parameters"]["videoLang"];
        include?: components["parameters"]["videoInclude"];
        limit?: components["parameters"]["limit"];
        offset?: components["parameters"]["offset"];
        paginated?: components["parameters"]["paginated"];
      };
      path: {
        channelId: components["parameters"]["channelId"];
        /** @description The type of video resource to fetch. Clips finds clip videos of a `vtuber` channel, Video finds the `channelId` channel's uploads, and collabs finds videos uploaded by other channels that mention this `channelId` */
        type: "clips" | "videos" | "collabs";
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": OneOf<
            [
              {
                total?: number;
                items?: components["schemas"]["VideoFull"][];
              },
              components["schemas"]["VideoFull"][],
            ]
          >;
        };
      };
    };
  };
  /**
   * Quickly Access Live / Upcoming for a set of Channels
   * @description This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.
   *
   * We recommends using this if you have a fixed set of channel IDs to look up status for.
   */
  "get-cached-live": {
    parameters: {
      query?: {
        /** @description comma separated Youtube Channel IDs */
        channels?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Video"][];
        };
      };
    };
  };
  /**
   * Get a single Video's metadata
   * @description Retrieves a video object.
   *
   * Also retrieves Comments if query parameter `c` is set.
   *
   * Also retrieves Recommendations if query parameter `lang` is set
   */
  "get-videos-videoId": {
    parameters: {
      query?: {
        lang?: components["parameters"]["videoLang"];
        /** @description if `1` then will reply with timestamp comments for this video */
        c?: "1" | "0";
      };
      path: {
        videoId: components["parameters"]["videoId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["VideoFull"] & {
            /** @description Comments are only returned if c === '1' */
            comments?: components["schemas"]["Comment"][];
            recommendations?: components["schemas"]["Video"][];
          };
        };
      };
    };
  };
  /** List Channels */
  "get-channels": {
    parameters: {
      query?: {
        type?: components["parameters"]["channelType"];
        offset?: components["parameters"]["offset"];
        limit?: components["parameters"]["limit"];
        /** @description If set, filter for Vtuber belonging to a specific org */
        org?: string;
        /** @description Comma separated list of languages. Language is a property of Channel, so only Channels satisfying the language will be returned. Leave empty to search for Vtubers and/or all clippers. */
        lang?: string;
        /** @description Column to sort on, leave default to use 'org' as sort. Any first level property of channel should work here. */
        sort?: string;
        /** @description ASC or DESC order, default asc. */
        order?: "asc" | "desc";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelWithGroup"][];
        };
      };
    };
  };
  /**
   * @description A flexible endpoint for retrieving videos that satisfy multiple conditions, where the "any" statement means an OR condition and "all" means an AND condition.
   *
   * Searching for topics and clips is not supported, because clips do not contain topic_ids
   */
  "post-search-videoSearch": {
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @default newest
           * @enum {string}
           */
          sort: "oldest" | "newest";
          /**
           * @description If set, will filter clips to only show clips with these langs + all vtuber streams (provided `target` is not set to filter out streams)
           * @example [
           *   "en",
           *   "ja"
           * ]
           */
          lang?: string[];
          /**
           * @description Target types of videos
           * @example [
           *   "clip",
           *   "stream"
           * ]
           */
          target?: ("clip" | "stream")[];
          /** @description Match all the following conditions */
          conditions?: {
            /**
             * @description Look for text in video title or description
             * @example VideoTitle
             */
            text?: string;
          }[];
          /**
           * @description Return videos that match one of the provided topics
           * @example [
           *   "singing",
           *   "apex"
           * ]
           */
          topic?: string[];
          /**
           * @description Videos with all of the specified channel
           * ids. If two or more channel IDs are specified, will only return their collabs, or if one channel is a clipper, it will only show clips of the other vtubers made by this clipper.
           * @example [
           *   "UChAn3c_AY5_I3Px5dig3X1Q",
           *   "UCvaTdHT2BGv3MKj3KVqJVCw"
           * ]
           */
          vch?: string[];
          /**
           * @description Videos of channels in any of the specified orgs, or clips that involve a channel in the specified org.
           * @example [
           *   "Hololive",
           *   "Nijisanji"
           * ]
           */
          org?: string[];
          /** @description If set at all, responds with total and items wrapping the array of objects */
          paginated?: boolean;
          offset: number;
          limit: number;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": OneOf<
            [
              components["schemas"]["VideoWithChannel"][],
              {
                total?: number;
                items?: components["schemas"]["VideoWithChannel"][];
              },
            ]
          >;
        };
      };
    };
  };
  /** @description A flexible endpoint to search for comments on videos that satisfy multiple conditions, where "any" means OR conditions and "all" means AND conditions. */
  "post-search-commentSearch": {
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @default newest
           * @enum {string}
           */
          sort: "oldest" | "newest";
          /**
           * @description If set, will filter clips to only show clips with these langs + all vtuber streams (provided `target` is not set to filter out streams)
           * @example [
           *   "en",
           *   "ja"
           * ]
           */
          lang?: string[];
          /**
           * @description Target types of videos
           * @example [
           *   "clip",
           *   "stream"
           * ]
           */
          target?: ("clip" | "stream")[];
          /**
           * @description Find videos with comments containing specified string (case insensitive)
           * @example Lemon
           */
          comment: string;
          /**
           * @description Return videos that match one of the provided topics
           * @example [
           *   "singing",
           *   "apex"
           * ]
           */
          topic?: string[];
          /**
           * @description Videos with all of the specified channel
           * ids. If two or more channel IDs are specified, will only return their collabs, or if one channel is a clipper, it will only show clips of the other vtubers made by this clipper.
           * @example [
           *   "UChAn3c_AY5_I3Px5dig3X1Q",
           *   "UCvaTdHT2BGv3MKj3KVqJVCw"
           * ]
           */
          vch?: string[];
          /**
           * @description Videos of channels in any of the specified orgs, or clips that involve a channel in the specified org.
           * @example [
           *   "Hololive",
           *   "Nijisanji"
           * ]
           */
          org?: string[];
          /** @description If set at all, responds with total and items wrapping the array of objects */
          paginated?: boolean;
          offset: number;
          limit: number;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": OneOf<
            [
              (components["schemas"]["VideoWithChannel"] & {
                comments?: components["schemas"]["Comment"][];
              })[],
              {
                total?: number;
                items?: (components["schemas"]["VideoWithChannel"] & {
                  comments?: components["schemas"]["Comment"][];
                })[];
              },
            ]
          >;
        };
      };
    };
  };
}
