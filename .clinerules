# Project Configuration

## Tech Stack
- Next.js 15+ with App Router
- Tailwind CSS for styling
- Supabase for backend
- Vercel for deployment
- GitHub for version control

## Project Structure

/apps
  /docs           # Documentation site
    /app         # Next.js App Router pages
    /components  # React components
    /content     # Documentation content

  /web           # Main application
    /app         # Next.js App Router pages
    /components  # React components
    /config      # Configuration files
    /const      # Constants
    /lib        # Utility functions
    /metrics    # Analytics components
    /oas        # OpenAPI specifications
    /stories    # Storybook stories
    /styles     # Global styles
    /types      # TypeScript types
    /public     # Static assets

/packages
  /tsconfig     # Shared TypeScript configurations
  /ui           # Shared UI components

## Database Migrations
Nothing

## Development Workflow
- Cline helps write and review code changes
- Vercel automatically deploys from main branch
- Database migrations reviewed by Cline before execution

## Security
DO NOT read or modify:
- .env files
- **/config/secrets.*
- Any file containing API keys or credentials

## Important

ユーザーは CLINE よりプログラミングが得意ですが、時短のために CLINE にコーディングを依頼しています。
2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方はユーザーが実装するよりも速いでしょう。
テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。
反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

## 作業開始前の確認

1. `git status` による変更確認
2. 指示と無関係な変更が多い場合は別タスクとして提案
3. 最新のブランチと同期を確認
4. 必要なツールとバージョンを確認

無視するように言われた場合は、そのまま続行します。

# 実装規約

## 基本原則

### 関数型プログラミング

```typescript
// 純粋関数の例
const calculateTotal = (items: readonly Item[]): Money => {
  return items.reduce(
    (total, item) => addMoney(total, item.price),
    ZERO_MONEY
  );
};

// 副作用の分離例
const saveOrder = async (order: Order): Promise<Result<Order, Error>> => {
  try {
    await orderRepository.save(order);
    return ok(order);
  } catch (error) {
    return err(toError(error));
  }
};
```

- 純粋関数を優先
- 不変データ構造を使用
- 副作用を分離・明示
- 型安全性を確保

### ドメイン駆動設計

```typescript
// 値オブジェクト
interface Price {
  readonly amount: Money;
  readonly currency: Currency;
  
  equals(other: Price): boolean;
  add(other: Price): Price;
}

// エンティティ
interface Order {
  readonly id: OrderId;
  readonly items: readonly OrderItem[];
  readonly status: OrderStatus;
  
  addItem(item: OrderItem): Result<Order, OrderError>;
  cancel(): Result<Order, OrderError>;
}
```

- 値オブジェクトとエンティティを区別
- 集約で整合性を保証
- リポジトリでデータアクセスを抽象化
- 境界付けられたコンテキストを意識

### テスト駆動開発

```typescript
describe('Order', () => {
  it('正常な注文を作成できる', () => {
    const result = createOrder({
      items: [validItem],
      userId: validUserId
    });
    
    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.value.items).toHaveLength(1);
      expect(result.value.status).toBe('pending');
    }
  });
  
  it('無効なアイテムで注文を作成できない', () => {
    const result = createOrder({
      items: [invalidItem],
      userId: validUserId
    });
    
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('invalid_item');
    }
  });
});
```

- Red-Green-Refactorサイクル
- テストを仕様として扱う
- 小さな単位で反復
- 継続的なリファクタリング

## 実装パターン

### 型定義

```typescript
// ブランデッド型
type Branded<T, B> = T & { readonly _brand: B };
type OrderId = Branded<string, 'OrderId'>;
type Money = Branded<number, 'Money'>;

// 列挙型
const OrderStatus = {
  Pending: 'pending',
  Confirmed: 'confirmed',
  Shipped: 'shipped',
  Cancelled: 'cancelled',
} as const;
type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];

// エラー型
type OrderError =
  | { type: 'invalid_items'; items: string[] }
  | { type: 'insufficient_stock'; itemId: string }
  | { type: 'already_cancelled' };
```

### 値オブジェクト

```typescript
// バリデーション付き作成関数
const createMoney = (amount: number): Result<Money, Error> => {
  if (!Number.isFinite(amount)) {
    return err(new Error('金額が無効です'));
  }
  if (amount < 0) {
    return err(new Error('金額が負です'));
  }
  return ok(amount as Money);
};

// 不変な値オブジェクト
const createPrice = (amount: Money, currency: Currency): Price => ({
  amount,
  currency,
  equals: (other: Price) => (
    amount === other.amount && currency === other.currency
  ),
  add: (other: Price) => {
    if (currency !== other.currency) {
      throw new Error('通貨単位が異なります');
    }
    return createPrice(
      (amount + other.amount) as Money,
      currency
    );
  }
});
```

### Result型とエラーハンドリング

```typescript
type Result<T, E> = Ok<T> | Err<E>;
type Ok<T> = { readonly ok: true; readonly value: T };
type Err<E> = { readonly ok: false; readonly error: E };

// ヘルパー関数
const ok = <T>(value: T): Ok<T> => ({ ok: true, value });
const err = <E>(error: E): Err<E> => ({ ok: false, error });

// エラー変換
const toError = (error: unknown): Error => {
  if (error instanceof Error) return error;
  return new Error(String(error));
};

// 結果の連鎖
const validateAndSaveOrder = (
  input: OrderInput
): Promise<Result<Order, OrderError>> => {
  return pipe(
    createOrder(input),
    (result) => result.ok
      ? saveOrder(result.value)
      : Promise.resolve(result)
  );
};
```

### リポジトリパターン

```typescript
interface OrderRepository {
  save(order: Order): Promise<void>;
  findById(id: OrderId): Promise<Option<Order>>;
  findByStatus(status: OrderStatus): Promise<Order[]>;
}

// インメモリ実装（テスト用）
class InMemoryOrderRepository implements OrderRepository {
  private orders = new Map<OrderId, Order>();
  
  async save(order: Order): Promise<void> {
    this.orders.set(order.id, order);
  }
  
  async findById(id: OrderId): Promise<Option<Order>> {
    return this.orders.get(id) || none;
  }
  
  // ...他のメソッド
}
```

### アダプターパターン

```typescript
// インターフェース（ドメイン層で定義）
interface PaymentGateway {
  processPayment(payment: Payment): Promise<Result<PaymentId, PaymentError>>;
  refundPayment(paymentId: PaymentId): Promise<Result<void, PaymentError>>;
}

// 実装（インフラ層）
class StripePaymentGateway implements PaymentGateway {
  constructor(private readonly client: Stripe) {}
  
  async processPayment(
    payment: Payment
  ): Promise<Result<PaymentId, PaymentError>> {
    try {
      const result = await this.client.charges.create({
        amount: payment.amount,
        currency: payment.currency,
        source: payment.token
      });
      return ok(result.id as PaymentId);
    } catch (error) {
      return err(this.translateError(error));
    }
  }
  
  // ...他のメソッド
}
```

## 実装手順

1. **要件分析とドメインモデリング**
   - ドメインの概念を特定
   - 値オブジェクトとエンティティを区分
   - 集約の境界を定義

2. **型設計**
   - ドメインの型を定義
   - エラー型を定義
   - DTOとドメインモデルの変換を定義

3. **テストケース作成**
   - 正常系のテスト
   - エラーケースのテスト
   - 境界値のテスト

4. **ドメインロジック実装**
   - 値オブジェクトの実装
   - エンティティの実装
   - ドメインサービスの実装

5. **インフラストラクチャ実装**
   - リポジトリの実装
   - アダプターの実装
   - 外部サービス連携の実装

## コーディングプラクティス

### 設計原則

- 単一責任の原則を遵守
- 依存関係を制御（依存性逆転の原則）
- インターフェースを小さく保つ
- 変更容易性を重視

### エラーハンドリング

- 早期検出と明示的なエラー型
- 境界でのバリデーション
- エラーの適切な変換と伝搬
- 回復可能なエラーの区別

### パフォーマンス

- 不要な計算の回避
- メモリ効率の考慮
- 非同期処理の適切な利用
- キャッシュの戦略的利用

## テスト戦略

### ユニットテスト

- 純粋関数の完全なテスト
- エッジケースの網羅
- テストデータの共通化
- テストヘルパーの活用

### 統合テスト

- 主要フローのテスト
- 外部依存のモック化
- データベーステスト
- APIテスト

### E2Eテスト

- クリティカルパスのテスト
- ユーザーシナリオベース
- 実環境に近い設定
- パフォーマンステスト
